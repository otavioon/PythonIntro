# Os Básicos da Linguagem de Programação Python

Python é uma linguagem de programação versátil e fácil de aprender. Como a maioria das linguagens, ela possui vários tipos básicos, incluindo:

- **Números**: inteiros e pontos flutuantes (que armazenam números reais).
- **Booleanos**: que armazenam `True` ou `False`.
- **Strings**: textos (cadeia de caracteres) que podem ser manipulados de várias formas.
- **Comentários**: começam com `#` e são ignorados pelo interpretador.

## Trabalhando com Variáveis

As variáveis em Python são "dinamicamente tipadas", o que significa que o tipo de uma variável é inferido com base no valor atribuído a ela. O tipo da variavel é muito importante pois os operadores podem desempenhar diferentes funções dependendo do tipo. 

Por exemplo, o operador `+` entre duas variaveis do tipo inteiro, resulta em uma variável do tipo inteiro. Já o operador ``+`` utilizado entre duas variáveis do tipo *string*, resulta em uma outra *string* que é a concatenação das duas. Por fim, o operador `*` entre uma variável do tipo *string* e um inteiro, resulta em uma nova *string* que é a repetição da *string* original o número de vezes do inteiro.

Para verificar o tipo de uma variável, podemos utilizar a função `type()`, que retorna o tipo da variável, como mostrado no exemplo abaixo:

```python
# Declarando variáveis
x = 3          # Inteiro
y = 3.5        # Float
z = "Python"   # String

# Verificando os tipos
print(type(x))  # <class 'int'>
print(type(y))  # <class 'float'>
print(type(z))  # <class 'str'>
```


Note que strings em python pode ser declaradas utilizando aspas simples ou duplas, como mostrado abaixo:

```python
s1 = 'Python'
s2 = "Python"
```

## Operações Básicas

Python suporta diversas operações com operadores aritméticos, lógicos e relacionais e eles podem ser utilizados com variáveis de diferentes tipos.

### Com variáveis do tipo inteiro ou float

Python suporta operações básicas como adição, subtração, multiplicação e divisão. Desta forma, dados duas variáveis do tipo inteiro, podemos realizar operações matemáticas usando operadores aritméticos, como mostrado abaixo:

| Operador | Descrição      | Exemplo        |
|----------|--------------- |--------------- |
| `+`      | Adição         | `3 + 2  →  5`  |
| `-`      | Subtração      | `5 - 2  →  3`  |
| `*`      | Multiplicação  | `3 * 2  →  6`  |
| `/`      | Divisão        | `3 / 2  →  1.5`|
| `//`     | Divisão inteira| `3 // 2  →  1` |
| `**`     | Exponenciação  | `3 ** 2  →  9` |

### Com variáveis do tipo booleano

Python usa palavras em inglês para operadores booleanos, em vez de símbolos como `&&` ou `||`. Os operadores booleanos mais comuns são `and`, `or` e `not`. Dado duas variáveis do tipo booleano, podemos realizar operações lógicas usando operadores booleanos, como mostrado abaixo:

| Operador | Descrição      | Exemplo                   |
|----------|----------------|---------------------------|
| `and`    | E lógico       | `True and False  →  False`|
| `or`     | Ou lógico      | `True or False  →  True`  |
| `not`    | Negação lógica | `not True  →  False`      |
| `!=`     | XOR lógico     | `True != False  →  True`  |

Por exemplo, podemos realizar operações lógicas com variáveis do tipo booleano, como mostrado abaixo:

```python
t = True
f = False
print(t and f)  # False
print(t or f)   # True
print(not t)    # False
print(t != f)   # True
```

### Com variáveis do tipo string

Python tem suporte robusto para manipulação de strings usando operadores básicos, como mostrado abaixo:

| Operador | Descrição      | Exemplo                                         |
|----------|----------------|-------------------------------------------------|
| `+`      | Concatenação   | `'Python' + ' é incrível' → 'Python é incrível'`|
| `*`      | Repetição      | `'Python' * 3  →  'PythonPythonPython'`         |
| `in`     | Verificação    | `'Python' in 'Python é incrível'  →  True`      |
| `not in` | Verificação    | `'Python' not in 'Python é incrível'  →  False` |

Veja que o primeiro operador é o operador de concatenação, que é utilizado para concatenar duas strings, e exige que o primeiro operando (a esquerda, antes do operador `+`) seja uma string e o segundo operando (a direita, depois do operador `+`) também seja uma string. 
Caso um dos operandos seja uma string e o outro seja um inteiro, teremos um erro de tipo, denominado `TypeError`. Isso pode ser observado no exemplo abaixo:

```python
a = "Python"
b = 3
print(a + b)  # TypeError: can only concatenate str (not "int") to str
```


Já para o operador de repetição, o primeiro operando deve ser uma string e o segundo operando deve ser um inteiro.

Por fim, os operadores `in` e `not in` são utilizados para verificar se uma string está contida em outra string. O operador `in` retorna `True` se a string está contida na outra string e `False` caso contrário. Já o operador `not in` retorna `True` se a string não está contida na outra string e `False` caso contrário.

## Trabalhando com Strings

Strings em Python são objetos poderosos que podem ser manipulados de várias formas.


### f-strings: Formatação de Strings

Desde a versão **3.5**, Python suporta f-strings, que permitem inserir expressões dentro de uma string de forma prática. Por exemplo, podemos utilizar f-strings para inserir o valor de variáveis dentro de uma string, como mostrado abaixo:

```python
x = 3
y = 3.5
z = "Python"
strings_concatenadas = f"O valor de x é {x}, y é {y} e z é {z}. A soma de x e y é {x + y}"
print(strings_concatenadas) # O valor de x é 3, y é 3.5 e z é Python. A soma de x e y é 6.5
```

Note que as f-strings são strings que começam com a letra `f` antes das aspas (simples ou duplas). 
Dentro da string, podemos inserir expressões entre chaves `{}` e o valor da expressão será inserido na string.
Se a expressão for uma variável, o valor da variável será inserido na string. Se a expressão for uma operação, o resultado da operação será inserido na string.

### Métodos de Strings

Uma string é um objeto em Python e, como tal, possui métodos que podem ser chamados para realizar operações específicas. Alguns métodos comuns de strings são:

| Método                | Descrição                          | Exemplo                                                           |
|-----------------------|------------------------------------|------------------------------------------------------------------ |
| `capitalize()`        | Primeira letra maiúscula           | `'python'.capitalize()  →  'Python'`                              |
| `lower()`             | Tudo minúsculo                     | `'Python'.lower()  →  'python'`                                   |
| `upper()`             | Tudo maiúsculo                     | `'Python'.upper()  →  'PYTHON'`                                   |
| `replace(old, new)`   | Substituir palavras                | `'Python é top'.replace('top', 'é top')  →  'Python é muito top'` |
| `strip()`             | Remover espaços extras             | `' Python é top! '.strip()  →  'Python é top!'`                   |



### Indexação de Strings

Podemos acessar caracteres individuais em uma string usando indexação. Em Python, a indexação começa em 0. Por exemplo, para acessar o primeiro caractere de uma string, usamos o índice 0:

```python
s = "Python"
print(s[0])  # P
print(s[1])  # y
print(s[0:3])  # Pyt
```

Note que a indexação de strings (ou qualquer outro tipo de sequência) é feita utilizando colchetes `[]` e o índice do caractere desejado. Quando queremos acessar um intervalo de caracteres, utilizamos dois pontos `:` para separar o índice inicial do índice final. O índice final não é incluído no intervalo. Como mostrado no exemplo acima, `s[0:3]` retorna os caracteres de índice 0, 1 e 2, (`P`, `y`, `t`) mas não inclui o caractere de índice 3 (que é o caractere `h`).

Para saber o tamanho de uma string, podemos utilizar a função `len()`, que retorna o tamanho da string, como mostrado no exemplo abaixo:

```python
s = "Python"
print(len(s))  # 6
```

## Funções em Python

Funções são blocos de código reutilizáveis que realizam uma tarefa específica. Em Python, as funções são definidas com a palavra-chave `def` seguida do nome da função e dos parâmetros entre parênteses. O bloco de código da função é indentado.
Por exemplo, podemos definir uma função que retorna o quadrado de um número:

```python
def quadrado(x):
    return x ** 2
```

A função `quadrado` recebe um parâmetro chamado `x` (primeiro parâmetro) e retorna o quadrado desse número. Podemos chamar essa função passando um argumento para o parâmetro `x`:

```python
print(quadrado(3))  # 9
```

As funções podem ter vários parâmetros e durante a chamada da função, os argumentos são passados para os parâmetros na ordem em que foram definidos. Por exemplo, podemos definir uma função que retorna a soma de dois números:

```python
def soma(x, y):
    return x + y
```

E chamamos essa função passando dois argumentos para os parâmetros `x` e `y`:

```python
print(soma(3, 2))  # 5
```

### Chamando Funções com Argumentos Nomeados

Em Python podemos chamar funções de duas formas:

1. **Argumentos posicionais**: passamos os argumentos na ordem em que os parâmetros foram definidos (como mostrado nos exemplos acima).
2. **Argumentos nomeados**: passamos os argumentos com o nome do parâmetro correspondente. Isso é útil quando a função tem muitos parâmetros e queremos passar apenas alguns deles.

Por exemplo, podemos definir uma função que recebe três parâmetros e retorna a soma deles:

```python
def soma(x, y, z):
    return x + y + z
```

Podemos chamar essa função passando os argumentos na ordem em que os parâmetros foram definidos:

```python
print(soma(3, 2, 1))  # 6
```

Ou podemos chamar essa função passando os argumentos com o nome do parâmetro correspondente:

```python
print(soma(x=3, y=2, z=1))  # 6
```

Quando usamos argumentos nomeados, podemos passar os argumentos em qualquer ordem, desde que o nome do argumento corresponda ao nome do parâmetro. Por exemplo, podemos chamar a função `soma` passando os argumentos na ordem `y`, `z` e `x`:

```python
print(soma(y=2, z=1, x=3))  # 6
```

> **NOTA** : Quando usamos argumentos nomeados, os argumentos sem nome devem vir antes dos argumentos nomeados. Por exemplo, `soma(3, y=2, z=1)` é válido, mas `soma(x=3, 2, 1)` resultará em um erro de sintaxe.

### Funções com Argumentos Padrão


Em Python, podemos definir valores padrão para os parâmetros de uma função. Isso significa que se um argumento não for passado durante a chamada da função, o valor padrão será utilizado. Por exemplo, podemos definir uma função que recebe um parâmetro `nome` e um parâmetro `saudacao` com um valor padrão:

```python
def saudacao(nome, saudacao="Olá"):
    return f"{saudacao}, {nome}!"
```

Se chamarmos essa função passando apenas o argumento para o parâmetro `nome`, o valor padrão para o parâmetro `saudacao` será utilizado:

```python
print(saudacao("João"))  # Olá, João!
```

Se chamarmos essa função passando argumentos para os parâmetros `nome` e `saudacao`, o valor passado para o parâmetro `saudacao` será utilizado:

```python
print(saudacao("Maria", "Oi"))  # Oi, Maria!
```

Podemos usar argumentos nomeados para passar o argumento para o parâmetro `nome` e deixar o valor padrão para o parâmetro `saudacao`:

```python
print(saudacao(nome="Carlos"))  # Olá, Carlos!
```

> **NOTA**: Quando usamos argumentos padrão, os argumentos sem padrão devem vir antes dos argumentos com padrão. Por exemplo, `def saudacao(nome, saudacao="Olá")`, mas `def saudacao(saudacao="Olá", nome)` resultará em um erro de sintaxe.


### Funções Embutidas

Python possui várias funções embutidas que estão disponíveis sem a necessidade de importar módulos. Alguns exemplos de funções embutidas são:

| Função               | Argumentos                     | Descrição                          | Exemplo                                                           |
|----------------------|------------------------------- |------------------------------------|------------------------------------------------------------------ |
| `print()`            | Único ou múltiplos objetos     | Imprime os objetos passados        | `print('Python', "é top") → Python é top`                         |
| `input()`            | Mensagem                       | Lê a entrada do usuário            | `nome = input('Qual é o seu nome? ')`                             |
| `type()`             | Objeto                         | Retorna o tipo do objeto           | `type(3)  →  <class 'int'>`                                       |
| `len()`              | Sequência                      | Retorna o tamanho da sequência     | `len('Python')  →  6`                                             |
| `str()`              | Objeto                         | Converte um objeto para string     | `str(3)  →  '3'`                                                  |
| `int()`              | Objeto                         | Converte um objeto para inteiro    | `int('3')  →  3`                                                  |
| `float()`            | Objeto                         | Converte um objeto para float      | `float('3.5')  →  3.5`                                            |
| `abs()`              | Número                         | Retorna o valor absoluto           | `abs(-3)  →  3`                                                   |
| `sum()`              | Sequência                      | Retorna a soma dos elementos       | `sum([1, 2, 3])  →  6`                                            |
| `max()`              | Sequência                      | Retorna o maior elemento           | `max([1, 2, 3])  →  3`                                            |
| `min()`              | Sequência                      | Retorna o menor elemento           | `min([1, 2, 3])  →  1`                                            |
| `abs()`              | Número                         | Retorna o valor absoluto           | `abs(-3)  →  3`                                                   |
| `round()`            | Número                         | Arredonda um número                | `round(3.5)  →  4`                                                |


## Classes e Objetos em Python

Python é uma linguagem de programação orientada a objetos (*OOP - Object-Oriented Programming*). Isso significa que tudo em Python é um objeto, desde números inteiros e strings até estruturas mais complexas como listas e dicionários.

Uma classe é um molde que define a estrutura e o comportamento dos objetos. A classe pode contemplar atributos (variáveis) e métodos (funções) que definem o comportamento dos objetos. Já um objeto é uma instância dessa classe. Diferentes objetos podem ser criados a partir da mesma classe, cada um com seus próprios atributos.


### Definindo uma Classe em Python

Para definir uma classe em Python, usamos a palavra-chave `class`. A convenção é nomear classes usando a convenção PascalCase, onde cada palavra começa com letra maiúscula. 
Vamos, por exemplo, pensar no caso de uma classe `Pessoa`, que possui os seguintes atributos: `nome`, `idade`, `peso` e `altura`. Além disso, a classe `Pessoa` possui os métodos `apresentar` e `calcular_imc`. O método `apresentar` retorna uma string com o nome e a idade da pessoa e o método `calcular_imc` retorna o índice de massa corporal da pessoa. Podemos definir essa classe em Python da seguinte forma:

```python
class Pessoa:
    def __init__(self, nome, idade, altura, peso):
        self.nome = nome
        self.idade = idade
        self.altura = altura
        self.peso = peso

    def apresentar(self):
        return f"Meu nome é {self.nome} e eu tenho {self.idade} anos"

    def calcular_imc(self):
        return self.peso / (self.altura ** 2)

    def apresentar_completo(self):
        apresentacao = self.apresentar()
        imc = self.calcular_imc()
        return f"{apresentacao} Meu IMC é {imc:.2f}."
```

Neste exemplo:

- `class Pessoa`: Define a classe Pessoa.
- `def __init__(self, nome, idade, altura, peso)`: O método especial `__init__` é o construtor da classe. Ele é chamado automaticamente ao criar um objeto. Desta forma, sempre que instanciarmos um objeto da classe `Pessoa`, precisamos passar um argumento para o parâmetro `nome`, `idade`, `altura` e `peso`.
- `self.nome = nome`: A variável `nome` se torna um atributo do objeto.
- `self.idade = idade`: A variável `idade` se torna um atributo do objeto.
- `self.altura = altura`: A variável `altura` se torna um atributo do objeto.
- `self.peso = peso`: A variável `peso` se torna um atributo do objeto.
- `def apresentar(self)`: Define um método que retorna uma string com o nome e a idade da pessoa.
- `def calcular_imc(self)`: Define um método que retorna o índice de massa corporal da pessoa.
- `def apresentar_completo(self)`: Define um método que chama o método `apresentar` e `calcular_imc` e retorna uma string mais completa com o IMC da pessoa.

> **Observação**: O parâmetro *self* sempre aparece nos métodos de uma classe (como o primeiro argumento). Ele representa a instância atual do objeto, permitindo acessar atributos e métodos dentro da própria classe. Não é necessário passar o argumento *self* ao chamar um método, pois o Python faz isso automaticamente.

### Criando Objetos (Instâncias) de uma Classe

Agora podemos criar objetos baseados na classe `Pessoa` e acessar seus atributos e métodos. Para criar um objeto, chamamos a classe como se fosse uma função, passando os parâmetros do método `__init__`. Uma vez que o objeto é criado, podemos acessar seus atributos e métodos usando a notação de ponto `.`. No exemplo abaixo, criamos dois objetos da classe `Pessoa`:

```python
p1 = Pessoa("Carlos", 30, altura=1.80, peso=80)
p2 = Pessoa("Ana", 18, altura=1.65, peso=60)

print(p1.apresentar())  # Meu nome é Carlos e eu tenho 30 anos
print(p2.apresentar())  # Meu nome é Ana e eu tenho 18 anos

print(p1.calcular_imc())  # 24.69
print(p2.calcular_imc())  # 22.04

print(p1.apresentar_completo())  # Meu nome é Carlos e eu tenho 30 anos. Meu IMC é 24.69.
print(p2.apresentar_completo())  # Meu nome é Ana e eu tenho 18 anos. Meu IMC é 22.04.
```

Aqui:
- `p1` e `p2` são objetos da classe `Pessoa`.
- `p1.apresentar()` e `p2.apresentar()` chamam o método `apresentar` para cada objeto.
- `p1.calcular_imc()` e `p2.calcular_imc()` chamam o método `calcular_imc` para cada objeto.
- `p1.apresentar_completo()` e `p2.apresentar_completo()` chamam o método `apresentar_completo` para cada objeto.


### Herança de classes: Reutilizando Código

A herança permite criar uma nova classe baseada em uma classe existente. Isso evita repetição de código, pois a nova classe herda atributos e métodos da classe base.
Por exemplo, um estudante é uma pessoa, mas também tem um curso. Podemos criar uma classe `Estudante`, que herda de `Pessoa` e adiciona um novo atributo, `curso`. Para herdar de uma classe, passamos a classe base entre parênteses ao definir a nova classe:

```python
class Estudante(Pessoa):
    def __init__(self, nome, idade, curso, altura, peso):
        super().__init__(nome, idade, altura, peso) # Chamamos o construtor da classe base
        self.curso = curso  # Novo atributo específico de Estudante

    def apresentar(self):
        nome_e_idade = super().apresentar()  # Chamamos o método da classe base
        return f"{nome_e_idade} e estou cursando {self.curso}."
```

No exemplo acima, a classe `Estudante` herda tudo da classe `Pessoa`. Entretanto, o método `__init__` possui um novo parâmetro `curso`. 
A função especial `super()` é usada para chamar métodos da classe pai (`Pessoa`) dentro da classe filha (`Estudante`). 
No exemplo acima, chamamos `super().__init__(nome, idade, altura, peso)` para chamar o construtor da classe `Pessoa` e evitar a duplicação de código. Logo após, adicionamos um novo atributo `curso` específico da classe `Estudante`. 


A classe `Estudante` também possui um método `apresentar` que sobrescreve o método `apresentar` da classe `Pessoa`. Dentro do método `apresentar` da classe `Estudante`, chamamos o método `apresentar` da classe `Pessoa` (`super().apresentar()`) e acrescentamos informações extras sobre o curso e retornamos uma string mais completa. Além disso, a classe `Estudante`  também possui o método `calcular_imc` que é herdado da classe `Pessoa` e não precisa ser redefinido.

Desta forma, podemos criar um objeto da classe `Estudante` e chamar o método `apresentar`, `calcular_imc` e `apresentar_completo`:

```python
e1 = Estudante("Lucas", 22, curso="Engenharia", altura=1.75, peso=70)
print(e1.calcular_imc())  # 22.86
print(e1.apresentar())  # Meu nome é Lucas e eu tenho 22 anos e estou cursando Engenharia.
print(e1.apresentar_completo())  # Meu nome é Lucas e eu tenho 22 anos e estou cursando Engenharia. Meu IMC é 22.86.
```

A classe `Estudante` reutilizou o método `apresentar` da classe `Pessoa` e apenas adicionou um detalhe extra. Isso evita repetição de código e facilita a manutenção.

Além disso, podemos verificar o tipo de um objeto em Python usando a função `type()`:

```python
print(type(p1))  # <class '__main__.Pessoa'>
print(type(e1))  # <class '__main__.Estudante'>
```

Por fim, os métodos `isinstance()` e `issubclass()` são usados para verificar se um objeto é uma instância de uma classe ou se uma classe é uma subclasse de outra classe, respectivamente. Por exemplo, podemos verificar se `e1` é uma instância de `Estudante` e `Pessoa`, usamos:

```python
print(isinstance(e1, Estudante))  # True
print(isinstance(e1, Pessoa))  # True
```

E se `Estudante` é uma subclasse de `Pessoa`:

```python
print(issubclass(Estudante, Pessoa))  # True
```

Note que `Estudante` é uma subclasse de `Pessoa`, pois `Estudante` herda de `Pessoa`. Além disso, `e1` é uma instância de `Estudante` e `Pessoa`, pois `e1` é um objeto da classe `Estudante` que herda de `Pessoa`.


### O Objeto `None` em Python (Objeto Vazio)

Em Python, o valor especial `None` representa um objeto vazio, sem valor ou tipo definido. Ele é frequentemente usado para indicar a ausência de um valor.

```python
x = None
print(x)          # None
print(type(x))    # <class 'NoneType'>
```

O tipo do objeto `None` é `NoneType`, que é um tipo único e indica que uma variável não foi inicializada com um valor válido.

#### Casos comuns onde `None` é usado

1. **Retorno padrão de funções sem `return`**:
   ```python
   def funcao_sem_retorno():
       pass

   resultado = funcao_sem_retorno()
   print(resultado)  # None
   ```
   Se uma função não retorna nada, ela automaticamente retorna `None`.

2. Indicar ausência de valor:
   ```python
   def buscar_usuario(id):
       if id == 1:
           return "Alice"
       else:
           return None  # Retorna None se o usuário não for encontrado

   usuario = buscar_usuario(2)
   if usuario is None:
       print("Usuário não encontrado!")
   ```
   Aqui, `None` é usado para indicar que o usuário não existe.

3. **Inicializar variáveis que serão definidas depois**:
   ```python
   resultado = None  # Inicializa sem valor definido
   if True:
       resultado = "Sucesso!"
   print(resultado)  # Sucesso!
   ```

## Estruturas de Dados em Python

Python fornece várias estruturas de dados embutidas, sendo as mais comuns:
- **Listas (list)**: coleções ordenadas e mutáveis de itens.
- **Tuplas (tuple)**: coleções ordenadas e imutáveis de itens.
- **Dicionários (dict)**: coleções não ordenadas de pares chave-valor.
- **Conjuntos (set)**: coleções não ordenadas de itens únicos.

Vamos ver como usar cada uma delas.

### Listas

Uma lista em Python é equivalente a um vetor, mas pode ser redimensionada para acomodar novos elementos de diferentes tipos. As listas possuem as seguintes características:

* Um objeto do tipo lista pode ser criado utilizando [] ou list() e pode conter elementos de diferentes tipos.

```python
lista1 = [1, 2, 3, "Python"]
lista2 = list((1, 2, 3, "Python"))
lista3 = []  # Lista vazia
```

* Os elementos de uma lista podem ser acessados por seu indice, ou acessados de maneira reversa com seu indice negativo. Note que o indice começa em 0 e, para indices negativos, -1 é o último elemento, -2 é o penúltimo elemento e assim por diante.

```python
lista = [1, 2, 3, "Python", Estudante("Lucas", 22, curso="Engenharia", altura=1.75, peso=70)]
print(lista[0])  # 1
print(lista[-1])  # <__main__.Estudante object at 0x7f8b1c1b5d90>
print(lista[-2])  # Python
```

* Listas podem conter objetos de diferentes tipos, incluindo outras listas. Neste caso, podem ser acessados utilizando indices múltiplos. Por exemplo, uma lista de listas:

```python
matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matriz[0][1])  # 2
```

* Elementos podem ser anexados a lista com o auxilio da função ``append``:

```python
lista = [1, 2, 3, "Python"]
lista.append("Novo elemento")
print(lista)  # [1, 2, 3, 'Python', 'Novo elemento']
```

* Elementos podem ser removidos da lista com o auxilio da função ``remove``:

```python
lista = [1, 2, 3, "Python"]
lista.remove(2)
print(lista)  # [1, 3, 'Python']
```

* Elementos podem ser inseridos em qualquer posição com o uso da função ``insert``. Entretanto, caso a posição seja maior que o tamanho da lista, o elemento é inserido no final da lista (append).

```python
lista = [1, 2, 3, "Python"]
lista.insert(1, "Novo elemento")
print(lista)  # [1, 'Novo elemento', 2, 3, 'Python']
```

* O tamanho da lista (numero de elementos) pode ser retornado com o auxilio da função ``len``:

```python
lista = [1, 2, 3, "Python"]
print(len(lista))  # 4
```

* O operador ``+`` aplicado a dois operandos do tipo lista, resulta numa terceira lista que é a concatenação das duas:

```python
lista1 = [1, 2, 3]
lista2 = [4, 5, 6]
lista3 = lista1 + lista2
print(lista3)  # [1, 2, 3, 4, 5, 6]
```

* O operador ``*`` aplicado a um operando do tipo lista e um operando do tipo inteiro, resulta numa lista que é a repetição da lista original:

```python
lista = [1, 2, 3]
lista_repetida = lista * 3
print(lista_repetida)  # [1, 2, 3, 1, 2, 3, 1, 2, 3]
```

* Podemos verificar se um elemento está na lista com a palavra-chave ``in``:

```python
lista = [1, 2, 3, "Python"]
print(1 in lista)  # True
print(4 in lista)  # False
```

* O último elemento da lista pode ser removido com o auxilio da função ``pop``:

```python
lista = [1, 2, 3, "Python"]
lista.pop()
print(lista)  # [1, 2, 3]
```

* A lista pode ser revertida com o auxilio da função ``reverse``:

```python
lista = [1, 2, 3, "Python"]
lista.reverse()
print(lista)  # ['Python', 3, 2, 1]
```

* A lista pode ser ordenada com o auxilio da função ``sort``:

```python
lista = [3, 1, 2, 4]
lista.sort()
print(lista)  # [1, 2, 3, 4]
```

* Mais informações sobre as funções de listas podem ser acessadas na [documentação do python](https://docs.python.org/3.9/tutorial/datastructures.html#more-on-lists). Existem varias funções como contagem, indices, remoção por elemento etc.


#### Fatias de Listas

Podemos acessar uma parte de uma lista usando fatias. A sintaxe para fatias é `lista[inicio:fim]`, onde `inicio` é o índice do primeiro elemento e `fim` é o índice do elemento após o último elemento. Por exemplo, para acessar os elementos de índice 1 e 2 de uma lista, usamos `lista[1:3]`:

```python
lista = [1, 2, 3, 4, 5]
print(lista[1:3])  # [2, 3]
```

Note que o índice `inicio` é inclusivo e o índice `fim` é exclusivo. Se omitirmos o índice `inicio`, a fatia começa do início da lista (0). Se omitirmos o índice `fim`, a fatia vai até o final da lista (`len(lista)`). Por exemplo:

```python
lista = [1, 2, 3, 4, 5]
print(lista[:3])  # [1, 2, 3]  (do início até o índice 3)
print(lista[2:])  # [3, 4, 5]  (do índice 2 até o final)
print(lista[:])   # [1, 2, 3, 4, 5]  (toda a lista)
print(lista[0:len(lista)])  # [1, 2, 3, 4, 5]  (toda a lista)
```

Podemos também especificar um terceiro índice, chamado de passo, que indica quantos elementos devem ser pulados. A sintaxe para fatias com passo é `lista[inicio:fim:passo]`. Por exemplo, para acessar todos os elementos da lista com índices pares, usamos `lista[::2]`:

```python
lista = [1, 2, 3, 4, 5]
print(lista[0:len(lista):2])  # [1, 3, 5] (de 0 até o final, pulando de 2 em 2)
print(lista[::2])  # [1, 3, 5] (de 0 até o final, pulando de 2 em 2, forma mais compacta)
print(lista[::-1])  # [5, 4, 3, 2, 1] (de 0 até o final, pulando de -1 em -1, ou seja, invertendo a lista)
print(lista[::-2])  # [5, 3, 1] (de 0 até o final, pulando de -2 em -2, ou seja, invertendo a lista e pulando de 2 em 2)
```


#### Notas importantes

* Para copiar uma lista, não podemos simplesmente atribuir uma lista a outra variável, pois isso cria uma referência à lista original. Para criar uma cópia independente, podemos usar a função ``copy``:

```python
lista1 = [1, 2, 3]
lista2 = lista1
lista3 = lista1.copy()
lista1.append(4)
print(lista1)  # [1, 2, 3, 4]
print(lista2)  # [1, 2, 3, 4]
print(lista3)  # [1, 2, 3]
```

* O uso do operador `*` repete os elementos da lista, mas não cria cópias dos objetos. Tipos primivos como inteiros e strings são imutáveis, então não há problema em repeti-los (sempre novos objetos serão criados). Entretanto, para objetos mutáveis, como a classe `Estudante` por exemplo, a repetição cria várias referências ao mesmo objeto:

```python
lista = [Estudante("Lucas", 22, curso="Engenharia", altura=1.75, peso=70)]
lista_repetida = lista * 3
lista_repetida[0].nome = "João"
print(lista_repetida[0].nome)  # João
print(lista_repetida[1].nome)  # João
print(lista_repetida[2].nome)  # João
```

Neste caso, caso queira que a referência seja independente, é necessário criar o objeto multiplas vezes, manualmente ou com o auxilio de um laço.
```python
lista_repetida = [Estudante("Lucas", 22, curso="Engenharia", altura=1.75, peso=70), Estudante("Lucas", 22, curso="Engenharia", altura=1.75, peso=70), Estudante("Lucas", 22, curso="Engenharia", altura=1.75, peso=70)]
lista_repetida[0].nome = "João"
print(lista_repetida[0].nome)  # João
print(lista_repetida[1].nome)  # Lucas
print(lista_repetida[2].nome)  # Lucas
```


* O uso de funções que usam comparações internas, como `sort`, `max`, `min` assumem que os elementos da lista são comparáveis entre si. Desta forma, para o uso destas funções, normalmente é necessário que os elementos da lista sejam do mesmo tipo ou que possam ser comparados entre si. Senão um erro do tipo `TypeError` será gerado.

```python
lista = [1, 2, 3, "Python"]
lista.sort()  # TypeError: '<' not supported between instances of 'str' and 'int'
```

#### Compreensão de Listas

Compreensão de listas é uma forma concisa de criar listas em Python. A sintaxe básica é `[expressao for item in lista]`, onde `expressao` é uma expressão que será aplicada a cada item da lista. Por exemplo, para criar uma lista com o quadrado dos números de 0 a 4, usamos:

```python
quadrados = [x ** 2 for x in range(5)]
print(quadrados)  # [0, 1, 4, 9, 16]
```

Podemos adicionar uma condição para filtrar os elementos da lista. A sintaxe é `[expressao for item in lista if condicao]`. Por exemplo, para criar uma lista com os quadrados dos números pares de 0 a 4, usamos:

```python
quadrados_pares = [x ** 2 for x in range(5) if x % 2 == 0]
print(quadrados_pares)  # [0, 4, 16]
```

Compreensão de listas é uma forma poderosa e concisa de criar listas em Python. Para mais informações, consulte a [documentação oficial do Python](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions).



### Tuplas

São semelhantes às listas, mas **imutáveis**. As tuplas são definidas com parênteses `()` ou com a função `tuple()`:

```python
tupla1 = (1, 2, 3, "Python")

tupla3 = tuple([1, 2, 3, "Python"])
```

Além disso, uma tupla de um único elemento pode ser criada com uma vírgula após o elemento. Por exemplo, ambos os exemplos abaixo criam uma tupla com um único elemento:

```python
tupla = 2,  # Uma tupla com um único elemento (note a vírgula no final)
tupla2 = (2,)
```

As tuplas possuem características semelhantes às listas, como indexação e fatias. No entanto, como as tuplas são imutáveis, não podemos adicionar, remover ou alterar elementos de uma tupla após a criação.

```python
tupla = (1, 2, 3, "Python")
print(tupla[0])  # 1
```

Os operadores `+` e `*` também podem ser usados com tuplas, assim como com listas. Entretanto, diferente das listas, o resultado é uma nova tupla e não uma modificação da tupla original.

```python
tupla1 = (1, 2, 3)
tupla2 = (4, 5, 6)
tupla3 = tupla1 + tupla2
print(tupla3)  # (1, 2, 3, 4, 5, 6)

tupla_repetida = tupla1 * 3
print(tupla_repetida)  # (1, 2, 3, 1, 2, 3, 1, 2, 3)
```

### Conjuntos

Conjuntos são coleções não ordenadas de elementos únicos. Os conjuntos são definidos com chaves `{}` ou com a função `set()`:

```python
conjunto1 = {1, 2, 3, "Python"}
conjunto2 = set([1, 2, 3, "Python"])
```

Caso queira criar um conjunto vazio, é necessário utilizar a função `set()`:

```python
conjunto_vazio = set()
```

Além disso, caso criarmos um conjunto com elementos repetidos, o conjunto irá remover as repetições:

```python
conjunto = {1, 2, 3, 1, 2, 3}
print(conjunto)  # {1, 2, 3}
```

Os conjuntos podem ser criados a partir de listas e tuplas, e vice-versa. Para converter um conjunto em uma lista, usamos a função `list()` e para converter uma lista em um conjunto, usamos a função `set()`:

```python
lista = [1, 2, 3, 1, 2, 3]
conjunto = set(lista)
print(conjunto)  # {1, 2, 3}

lista = list(conjunto)
print(lista)  # [1, 2, 3]
```

Algumas proprieadades dos conjuntos são:

* Os elementos de um conjunto não podem ser acessados por índices, pois conjuntos não são ordenados. No entanto, podemos verificar se um elemento está no conjunto com a palavra-chave `in`:

```python
conjunto = {1, 2, 3, "Python"}
print(1 in conjunto)  # True
print(4 in conjunto)  # False
```

* Elementos podem ser adicionados a um conjunto com o método `add`. Caso o elemento já exista no conjunto, ele não será adicionado novamente:

```python
conjunto = {1, 2, 3}
conjunto.add(4)
print(conjunto)  # {1, 2, 3, 4}
conjunto.add(2)
print(conjunto)  # {1, 2, 3, 4} (2 já existe no conjunto)
```

* Elementos podem ser removidos de um conjunto com o método `remove`. Caso o elemento não exista no conjunto, um erro do tipo `KeyError` será gerado:

```python
conjunto = {1, 2, 3}
conjunto.remove(2)
print(conjunto)  # {1, 3}
conjunto.remove(4)  # KeyError: 4
```

* O método `discard` remove um elemento do conjunto, mas não gera um erro caso o elemento não exista:

```python
conjunto = {1, 2, 3}
conjunto.discard(4) # Não gera erro
print(conjunto)  # {1, 2, 3}
```

* O método `pop` remove um elemento arbitrário do conjunto e o retorna. Caso o conjunto esteja vazio, um erro do tipo `KeyError` será gerado:

```python
conjunto = {1, 2, 3}
elemento = conjunto.pop()
print(elemento)  # 1, 2 ou 3
print(conjunto)  # {2, 3}
```

* O método `clear` remove todos os elementos do conjunto:

```python
conjunto = {1, 2, 3}
conjunto.clear()
print(conjunto)  # set()
```

* O método `union` retorna a união de dois conjuntos, ou seja, um novo conjunto contendo todos os elementos dos conjuntos originais:

```python
conjunto1 = {1, 2, 3}
conjunto2 = {3, 4, 5}
uniao = conjunto1.union(conjunto2)
print(uniao)  # {1, 2, 3, 4, 5}
```

* O método `intersection` retorna a interseção de dois conjuntos, ou seja, um novo conjunto contendo apenas os elementos que estão presentes em ambos os conjuntos originais:

```python
conjunto1 = {1, 2, 3}
conjunto2 = {3, 4, 5}
intersecao = conjunto1.intersection(conjunto2)
print(intersecao)  # {3}
```

* O método `difference` retorna a diferença entre dois conjuntos, ou seja, um novo conjunto contendo apenas os elementos que estão presentes no primeiro conjunto, mas não no segundo:

```python
conjunto1 = {1, 2, 3}
conjunto2 = {3, 4, 5}
diferenca = conjunto1.difference(conjunto2)
print(diferenca)  # {1, 2}
```

* O método `symmetric_difference` retorna a diferença simétrica entre dois conjuntos, ou seja, um novo conjunto contendo apenas os elementos que estão presentes em um dos conjuntos, mas não em ambos:

```python
conjunto1 = {1, 2, 3}
conjunto2 = {3, 4, 5}
diferenca_simetrica = conjunto1.symmetric_difference(conjunto2)
print(diferenca_simetrica)  # {1, 2, 4, 5}
```

* Mais informações sobre conjuntos podem ser acessadas na [documentação do python](https://docs.python.org/3.9/library/stdtypes.html#set-types-set-frozenset).


### Dicionários

Dicionários são coleções não ordenadas de pares chave-valor. Os dicionários são definidos com chaves `{}` ou com a função `dict()`. Entretanto, diferente dos conjuntos, os dicionários são definidos com pares chave-valor separados por dois pontos `:`:

```python
dicionario1 = {"nome": "Carlos", "idade": 30, "curso": "Engenharia"}
dicionario2 = dict(nome="Carlos", idade=30, curso="Engenharia")
```

Dicionários podem ser criados vazios, sem pares chave-valor:

```python
dicionario_vazio = {}
dicionario_vazio = dict()
```

Além disso, os dicionários possuem as seguintes características:

* Os valores de um dicionário podem ser acessados por suas chaves:

```python
dicionario = {"nome": "Carlos", "idade": 30, "curso": "Engenharia"}
print(dicionario["nome"])  # Carlos
```

* Podemos adicionar um novo par chave-valor a um dicionário simplesmente atribuindo um valor a uma nova chave:

```python
dicionario = {"nome": "Carlos", "idade": 30}
dicionario["curso"] = "Engenharia"
print(dicionario)  # {'nome': 'Carlos', 'idade': 30, 'curso': 'Engenharia'}
```

* Podemos remover um par chave-valor de um dicionário com a palavra-chave `del`:

```python
dicionario = {"nome": "Carlos", "idade": 30, "curso": "Engenharia"}
del dicionario["idade"]
print(dicionario)  # {'nome': 'Carlos', 'curso': 'Engenharia'}
```

* Podemos verificar se uma chave está presente em um dicionário com a palavra-chave `in`:

```python
dicionario = {"nome": "Carlos", "idade": 30, "curso": "Engenharia"}
print("nome" in dicionario)  # True
print("altura" in dicionario)  # False
```

* Podemos acessar todas as chaves de um dicionário com o método `keys` e todos os valores com o método `values`. Ambos retornam objetos especiais (que podem ser convertidos em listas usando `list()`), que representam as chaves e valores do dicionário, respectivamente:

```python
dicionario = {"nome": "Carlos", "idade": 30, "curso": "Engenharia"}
print(dicionario.keys())  # dict_keys(['nome', 'idade', 'curso'])
print(dicionario.values())  # dict_values(['Carlos', 30, 'Engenharia'])
```

* Podemos acessar todos os pares chave-valor de um dicionário com o método `items`. Este método retorna uma lista de tuplas, onde cada tupla contém uma chave e seu valor correspondente:

```python
dicionario = {"nome": "Carlos", "idade": 30, "curso": "Engenharia"}
dicionario.items()  # dict_items([('nome', 'Carlos'), ('idade', 30), ('curso', 'Engenharia')])
```

* Podemos copiar um dicionário com o método `copy`. Diferente das listas, a cópia de um dicionário não é uma referência ao dicionário original, mas sim uma cópia independente:

```python
dicionario = {"nome": "Carlos", "idade": 30, "curso": "Engenharia"}
dicionario_copia = dicionario.copy()
dicionario_copia["nome"] = "João"
print(dicionario)  # {'nome': 'Carlos', 'idade': 30, 'curso': 'Engenharia'}
print(dicionario_copia)  # {'nome': 'João', 'idade': 30, 'curso': 'Engenharia'}
```

> **Nota**: Para tipos não primitivos, como listas, dicionários e instancias de classes, a cópia é uma cópia rasa, ou seja, a cópia é uma referência aos mesmos objetos.

* `KeyError` é gerado caso uma chave não exista no dicionário:

```python
dicionario = {"nome": "Carlos", "idade": 30, "curso": "Engenharia"}
print(dicionario["altura"])  # KeyError: 'altura'
```

* Mais informações sobre dicionários podem ser acessadas na [documentação do python](https://docs.python.org/3.9/library/stdtypes.html#mapping-types-dict).


#### Compreensão de Dicionários

Compreensão de dicionários é uma forma concisa de criar dicionários em Python. A sintaxe básica é `{chave: valor for item in lista}`. Por exemplo, para criar um dicionário com o quadrado dos números de 0 a 4, usamos:

```python
quadrados = {x: x ** 2 for x in range(5)}
print(quadrados)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

Para mais informações, consulte a [documentação oficial do Python](https://docs.python.org/3/tutorial/datastructures.html#dictionaries).


## Tratamento de Erros

Podemos capturar exceções em Python com `try` e `except`:

```python
try:
    x = int("abc")  # Isso gera um erro do tipo ValueError, pois "abc" não pode ser convertido para inteiro
except ValueError as e:
    print(f"Erro: {e}")
```

Principais erros (exceções) em Python:

| Erro         | Descrição                          |
|--------------|------------------------------------|
| `TypeError`  | Operação entre tipos incompatíveis |
| `IndexError` | Índice fora do intervalo da lista  |
| `KeyError`   | Chave não encontrada no dicionário |
| `ValueError` | Tipo de dado inválido              |
